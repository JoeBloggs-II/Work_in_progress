<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Flappy Bird — Keyboard Controlled Flappy Bird</title>
  <style>
    :root{--bg:#70c5ce;--bird:#ffcc00;--pipe:#228B22;--ground:#de9b45}
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(#80d7e0,#53c0d0);}
    .game-wrap{width:480px;max-width:92vw;background:linear-gradient(#aeeaf0,#9fe7ee);box-shadow:0 8px 30px rgba(0,0,0,0.18);border-radius:12px;overflow:hidden}
    header{padding:8px 12px;background:rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:space-between}
    header h1{font-size:14px;margin:0}
    #game{background:var(--bg);display:block;width:100%;height:640px}
    .overlay{position:absolute;left:0;right:0;text-align:center;padding:6px 10px;background:linear-gradient(transparent,rgba(0,0,0,0.08));color:#042;}
    .controls{font-size:13px;color:#044;margin-right:6px}
    .footer{display:flex;justify-content:space-between;padding:8px 12px;background:rgba(255,255,255,0.04);font-size:13px}
    button{border:0;background:#fff;padding:6px 10px;border-radius:6px;cursor:pointer}
    button:active{transform:translateY(1px)}
    .small{font-size:12px;color:#064}
    /* simple responsive scaling */
    @media (max-width:520px){#game{height:540px}}
  </style>
</head>
<body>
  <div class="game-wrap">
    <header>
      <h1>Flappy Bird — press Space or ↑ to flap</h1>
      <div class="controls">Score: <span id="score">0</span></div>
    </header>

    <div style="position:relative">
      <canvas id="game"></canvas>
      <div class="overlay" id="message" style="display:none;position:absolute;top:40%;transform:translateY(-50%);pointer-events:none">
        <div style="background:rgba(255,255,255,0.92);display:inline-block;padding:14px 18px;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,0.12)">
          <div id="msg-title" style="font-weight:700;font-size:18px;margin-bottom:6px">Paused</div>
          <div id="msg-body" style="margin-bottom:8px">Press Space or ↑ to start. R to restart anytime.</div>
          <div style="font-size:12px;color:#333">Keyboard: Space / Up to flap — R to restart</div>
        </div>
      </div>
    </div>

    <div class="footer">
      <div class="small">Physics: gravity + velocity, simple AABB collision</div>
      <div>
        <button id="btn-start">Start / Resume</button>
        <button id="btn-reset">Reset</button>
      </div>
    </div>
  </div>

  <script>
  // Flappy bird-like game implemented in a single HTML file.
  // Controls: Space or ArrowUp to flap, R to restart, click Start to resume.

  (function(){
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const msg = document.getElementById('message');
    const msgTitle = document.getElementById('msg-title');
    const msgBody = document.getElementById('msg-body');
    const btnStart = document.getElementById('btn-start');
    const btnReset = document.getElementById('btn-reset');

    // resolution handling
    function fitCanvas(){
      const DPR = Math.min(window.devicePixelRatio || 1, 2);
      const styleW = Math.min(480, Math.floor(window.innerWidth*0.92));
      const styleH = Math.floor(styleW * (640/480));
      canvas.style.width = styleW + 'px';
      canvas.style.height = styleH + 'px';
      canvas.width = Math.floor(styleW * DPR);
      canvas.height = Math.floor(styleH * DPR);
      ctx.setTransform(DPR,0,0,DPR,0,0);
    }
    window.addEventListener('resize', fitCanvas);
    fitCanvas();

    // Game constants
    const GAME_W = () => canvas.clientWidth;
    const GAME_H = () => canvas.clientHeight;

    const groundHeight = 60;
    const gravity = 1200; // px/s^2
    const flapSpeed = -350; // px/s (instant velocity set)
    const pipeWidth = 60;
    const pipeGap = 150; // vertical gap size
    const pipeSpacing = 230; // horizontal distance between pipes
    const pipeSpeed = 160; // px/s

    // State
    let bird = null;
    let pipes = [];
    let lastTime = 0;
    let spawnTimer = 0;
    let score = 0;
    let running = false;
    let gameOver = false;

    function resetState(){
      bird = { x:80, y: GAME_H()/2, w:34, h:24, vy:0, rotation:0 };
      pipes = [];
      lastTime = performance.now();
      spawnTimer = 0;
      score = 0;
      running = false;
      gameOver = false;
      updateScore();
      showMessage('Press Space or ↑ to start','');
    }

    // Utilities
    function rnd(min,max){return Math.random()*(max-min)+min}

    // Pipe generator: top and bottom rectangles with a gap
    function spawnPipe(){
      const h = GAME_H() - groundHeight;
      const gapY = rnd(80, h - 80 - pipeGap);
      const pipe = { x: GAME_W() + 10, gapY, width: pipeWidth, passed:false };
      pipes.push(pipe);
    }

    // Collision detection: axis-aligned bounding box
    function rectsOverlap(a,b){
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }

    function update(dt){
      if(!running) return;
      // bird physics
      bird.vy += gravity * dt;
      bird.y += bird.vy * dt;
      bird.rotation = Math.max(-0.6, Math.min(1.2, bird.vy / 600));

      // spawn pipes
      spawnTimer += dt*1000;
      if(spawnTimer > pipeSpacing){ spawnTimer = 0; spawnPipe(); }

      // move pipes
      for(let p of pipes){ p.x -= pipeSpeed * dt; }
      // remove offscreen
      pipes = pipes.filter(p => p.x + p.width > -50);

      // scoring and collision
      for(let p of pipes){
        if(!p.passed && p.x + p.width < bird.x){ p.passed = true; score++; updateScore(); }

        // top rect
        const topRect = { x: p.x, y: 0, w: p.width, h: p.gapY };
        const bottomRect = { x: p.x, y: p.gapY + pipeGap, w: p.width, h: GAME_H() - (p.gapY + pipeGap) - groundHeight };
        const birdRect = { x: bird.x - bird.w/2, y: bird.y - bird.h/2, w: bird.w, h: bird.h };
        if(rectsOverlap(birdRect, topRect) || rectsOverlap(birdRect, bottomRect)){
          // collision
          running = false; gameOver = true; showMessage('Game Over', 'Press R to restart');
        }
      }

      // ground collision
      if(bird.y + bird.h/2 > GAME_H() - groundHeight){
        bird.y = GAME_H() - groundHeight - bird.h/2;
        running = false; gameOver = true; showMessage('Game Over', 'You hit the ground — press R to try again');
      }

      // ceiling clamp
      if(bird.y - bird.h/2 < 0){ bird.y = bird.h/2; bird.vy = 0; }
    }

    function draw(){
      // clear
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // sky background (subtle gradient)
      const g = ctx.createLinearGradient(0,0,0,GAME_H());
      g.addColorStop(0,'#9fe7ee'); g.addColorStop(1,'#7ddfe6');
      ctx.fillStyle = g; ctx.fillRect(0,0,GAME_W(),GAME_H());

      // pipes
      for(let p of pipes){
        // top
        ctx.fillStyle = '#2e8b57';
        ctx.fillRect(p.x, 0, p.width, p.gapY);
        // bottom
        ctx.fillRect(p.x, p.gapY + pipeGap, p.width, GAME_H() - (p.gapY + pipeGap) - groundHeight);
        // caps (rounded look)
        ctx.fillStyle = '#196d3a'; ctx.fillRect(p.x-6, Math.max(0,p.gapY-10), p.width+12, 10);
      }

      // ground
      ctx.fillStyle = '#d99c44'; ctx.fillRect(0, GAME_H()-groundHeight, GAME_W(), groundHeight);
      // simple ground texture
      for(let i=0;i<GAME_W();i+=24){ ctx.fillStyle = 'rgba(0,0,0,0.03)'; ctx.fillRect(i, GAME_H()-groundHeight, 12, 6); }

      // bird (simple circle + wing)
      ctx.save();
      ctx.translate(bird.x, bird.y);
      ctx.rotate(bird.rotation);
      // body
      ctx.fillStyle = '#ffdd33'; ctx.beginPath(); ctx.ellipse(0,0,bird.w/2,bird.h/2,0,0,Math.PI*2); ctx.fill();
      // beak
      ctx.fillStyle = '#ff8c00'; ctx.beginPath(); ctx.moveTo(bird.w/2-2,0); ctx.lineTo(bird.w/2+12,6); ctx.lineTo(bird.w/2+12,-6); ctx.closePath(); ctx.fill();
      // eye
      ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(4,-4,3,0,Math.PI*2); ctx.fill();
      // wing (flap more when vy negative)
      const wingOffset = Math.max(-6, Math.min(12, -bird.vy/20));
      ctx.fillStyle = 'rgba(0,0,0,0.08)'; ctx.beginPath(); ctx.ellipse(-2, wingOffset, 10,6, Math.PI/6,0,Math.PI*2); ctx.fill();
      ctx.restore();

      // score (big center)
      ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.font = '600 48px system-ui'; ctx.textAlign = 'center';
      ctx.fillText(score, GAME_W()/2, 80);
    }

    function gameLoop(now){
      const dt = Math.min(0.05, (now - lastTime)/1000);
      lastTime = now;
      update(dt);
      draw();
      requestAnimationFrame(gameLoop);
    }

    // input
    function flap(){
      if(gameOver) return;
      if(!running){ running = true; hideMessage(); }
      bird.vy = flapSpeed;
    }

    window.addEventListener('keydown', (e)=>{
      if(e.code === 'Space' || e.code === 'ArrowUp'){
        e.preventDefault(); flap();
      }
      if(e.key === 'r' || e.key === 'R'){
        resetState();
      }
      if(e.code === 'KeyP'){
        running = !running; showMessage(running ? '': 'Paused', running ? '': 'Press Space to resume');
      }
    });

    // touch / click for mobile
    canvas.addEventListener('pointerdown', (e)=>{ flap(); });

    function updateScore(){ scoreEl.textContent = score; }

    function showMessage(title, body){
      msgTitle.textContent = title || '';
      msgBody.textContent = body || '';
      msg.style.display = 'block';
    }
    function hideMessage(){ msg.style.display = 'none'; }

    btnStart.addEventListener('click', ()=>{ if(gameOver) return; running = true; hideMessage(); });
    btnReset.addEventListener('click', resetState);

    // initialize
    resetState();
    requestAnimationFrame((t)=>{ lastTime = t; requestAnimationFrame(gameLoop); });

  })();
  </script>
</body>
</html>
