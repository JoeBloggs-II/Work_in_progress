<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Voxel Engine (Proper Camera)</title>
<style>
  body { margin:0; overflow:hidden; background:#87CEEB; }
  canvas { display:block; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
canvas.width = innerWidth;
canvas.height = innerHeight;

const WIDTH = canvas.width;
const HEIGHT = canvas.height;

const deg = a => a * Math.PI / 180;

// Camera
let cam = { x: 2, y: 1.5, z: 5 };
let yaw = 0;
let pitch = 0;

// Controls
const keys = {};
window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

document.addEventListener("mousemove", e => {
  if (document.pointerLockElement === canvas) {
    yaw -= e.movementX * 0.002;
    pitch -= e.movementY * 0.002;
    pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
  }
});
canvas.addEventListener("click", () => canvas.requestPointerLock());

// Load textures
const tex = {
  top: new Image(),
  bottom: new Image(),
  side: new Image()
};
tex.top.src = "assets/top.jpeg";
tex.bottom.src = "assets/bottom.jpeg";
tex.side.src = "assets/side.jpeg";

// Cube model (unit cube)
const cubeVerts = [
  [0,0,0],[1,0,0],[1,0,1],[0,0,1], // bottom
  [0,1,0],[1,1,0],[1,1,1],[0,1,1]  // top
];

// Each face: vertices + texture
const faces = [
  {v:[4,5,6,7], img:"top"},    // top
  {v:[0,1,2,3], img:"bottom"}, // bottom
  {v:[3,2,6,7], img:"side"},   // front
  {v:[0,1,5,4], img:"side"},   // back
  {v:[1,2,6,5], img:"side"},   // right
  {v:[0,3,7,4], img:"side"}    // left
];

// Simple world (3x3 dirt platform)
const world = [];
for (let x=0; x<3; x++) for (let z=0; z<3; z++) world.push({x,y:0,z});

// Projection
function project(x, y, z) {
  // Translate relative to camera
  let dx = x - cam.x;
  let dy = y - cam.y;
  let dz = z - cam.z;

  // Rotate by yaw
  const cosy = Math.cos(yaw), siny = Math.sin(yaw);
  const dxz = dx * cosy - dz * siny;
  const dzx = dx * siny + dz * cosy;

  // Rotate by pitch
  const cosp = Math.cos(pitch), sinp = Math.sin(pitch);
  const dyz = dy * cosp - dzx * sinp;
  const dzz = dy * sinp + dzx * cosp;

  const fov = 500;
  const sx = (dxz * fov / dzz) + WIDTH / 2;
  const sy = (-dyz * fov / dzz) + HEIGHT / 2;
  return {x: sx, y: sy, z: dzz};
}

function updateCamera() {
  const speed = 0.1;
  const forward = { x: Math.sin(yaw), z: Math.cos(yaw) };
  const right = { x: Math.cos(yaw), z: -Math.sin(yaw) };
  if (keys['w']) { cam.x += forward.x*speed; cam.z += forward.z*speed; }
  if (keys['s']) { cam.x -= forward.x*speed; cam.z -= forward.z*speed; }
  if (keys['a']) { cam.x += right.x*speed; cam.z += right.z*speed; }
  if (keys['d']) { cam.x -= right.x*speed; cam.z -= right.z*speed; }
  if (keys[' ']) cam.y += speed;
  if (keys['shift']) cam.y -= speed;
}

function drawFace(face, block) {
  const verts = face.v.map(i=>{
    const v = cubeVerts[i];
    return project(v[0]+block.x, v[1]+block.y, v[2]+block.z);
  });

  // Backface culling (only draw if facing camera)
  const ax = verts[1].x - verts[0].x;
  const ay = verts[1].y - verts[0].y;
  const bx = verts[2].x - verts[0].x;
  const by = verts[2].y - verts[0].y;
  const cross = ax*by - ay*bx;
  if (cross < 0) return; // facing away

  // Draw texture as simple quad
  const minX = Math.min(...verts.map(v=>v.x));
  const maxX = Math.max(...verts.map(v=>v.x));
  const minY = Math.min(...verts.map(v=>v.y));
  const maxY = Math.max(...verts.map(v=>v.y));
  const w = maxX - minX, h = maxY - minY;
  const img = tex[face.img];
  if (img.complete) ctx.drawImage(img, minX, minY, w, h);
}

function loop() {
  ctx.clearRect(0,0,WIDTH,HEIGHT);
  updateCamera();

  // Collect visible faces and sort by distance
  const drawList = [];
  for (let block of world) {
    for (let f of faces) {
      const center = project(block.x+0.5, block.y+0.5, block.z+0.5);
      if (center.z > 0) drawList.push({block, face:f, dist:center.z});
    }
  }
  drawList.sort((a,b)=>b.dist-a.dist);

  for (let item of drawList) drawFace(item.face, item.block);

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
