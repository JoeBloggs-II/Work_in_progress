<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mandelbrot Set - WebGPU</title>
  <style>
    body { margin: 0; background: black; }
    canvas { width: 100vw; height: 100vh; display: block; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script type="module">
    const canvas = document.getElementById('canvas');
    const adapter = await navigator.gpu.requestAdapter();
    const device = await adapter?.requestDevice();
    if (!device) {
      alert("WebGPU not supported.");
      throw new Error("WebGPU not supported");
    }
    const context = canvas.getContext('webgpu');
    const format = navigator.gpu.getPreferredCanvasFormat();
    context.configure({ device, format });

    const shader = `
      struct Uniforms { 
        width: f32, height: f32, zoom: f32, offsetX: f32, offsetY: f32
      };
      @group(0) @binding(0) var<uniform> uniforms: Uniforms;

      @fragment
      fn main(@builtin(position) pos: vec4f) -> @location(0) vec4f {
        let uv = vec2f(pos.x / uniforms.width, pos.y / uniforms.height);
        let x0 = (uv.x - 0.5) * 3.0 / uniforms.zoom + uniforms.offsetX;
        let y0 = (uv.y - 0.5) * 2.0 / uniforms.zoom + uniforms.offsetY;
        var x = 0.0;
        var y = 0.0;
        var iter = 0;
        let max_iter = 500;
        while (x*x + y*y <= 4.0 && iter < max_iter) {
          let xtemp = x*x - y*y + x0;
          y = 2.0*x*y + y0;
          x = xtemp;
          iter++;
        }
        let t = f32(iter) / f32(max_iter);
        return vec4f(t, t*t, t*t*t, 1.0); // Smooth gradient
      }
    `;

    const module = device.createShaderModule({ code: shader });

    const pipeline = device.createRenderPipeline({
      layout: "auto",
      vertex: {
        module,
        entryPoint: "vs_main",
        // Simple fullscreen triangle vertex shader
        code: `
          @vertex
          fn vs_main(@builtin(vertex_index) idx: u32) -> @builtin(position) vec4f {
            var pos = array<vec2f, 3>(
              vec2f(-1.0, -1.0),
              vec2f( 3.0, -1.0),
              vec2f(-1.0,  3.0)
            );
            return vec4f(pos[idx], 0.0, 1.0);
          }
        `
      },
      fragment: {
        module,
        entryPoint: "main",
        targets: [{ format }]
      },
      primitive: { topology: "triangle-list" }
    });

    const uniformBuffer = device.createBuffer({
      size: 5 * 4,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    const bindGroup = device.createBindGroup({
      layout: pipeline.getBindGroupLayout(0),
      entries: [{ binding: 0, resource: { buffer: uniformBuffer } }]
    });

    function frame() {
      const width = canvas.width = window.innerWidth;
      const height = canvas.height = window.innerHeight;
      const zoom = 1.0;
      const offsetX = -0.5;
      const offsetY = 0.0;

      device.queue.writeBuffer(uniformBuffer, 0, new Float32Array([
        width, height, zoom, offsetX, offsetY
      ]));

      const encoder = device.createCommandEncoder();
      const pass = encoder.beginRenderPass({
        colorAttachments: [{
          view: context.getCurrentTexture().createView(),
          loadOp: "clear",
          clearValue: { r: 0, g: 0, b: 0, a: 1 },
          storeOp: "store"
        }]
      });
      pass.setPipeline(pipeline);
      pass.setBindGroup(0, bindGroup);
      pass.draw(3);
      pass.end();
      device.queue.submit([encoder.finish()]);
      requestAnimationFrame(frame);
    }

    frame();
  </script>
</body>
</html>
